\section{Практическая часть}
\subsection{Реализация алгоритма}
Приступим к описанию непосредственной реализации вышеописанного алгоритма. 
В роли банкира будет выступать отдельный процесс, являющийся якобы частью ОС. Он должен обрабатывать пользовательские запросы и хранить информацию о том, как на данный момент распределены ресусы. Пользовательские процессы взаимодействуют с ним через библиотеку <<deadlock.h>>. Запросы от пользовательских процессов поступают в очередь, из которой и берет их <<банкир>>. Все оригинальные системные вызовы выполняются библиотекой только после отправки запроса и получения ответа (при необходимости).
В случае ошибки все функции возвращают отрицательные значения. 
Описание функций, досупных из библиотеки:

\begin{itemize}
    \item int my\_semget(key\_t key, int nsems,int semflg,int max\_resourses) функция получающая идентификационный номер семафора. В зависимости от того подключается или создает свой набор семафоров отсылает либо запрос о новом пользователе, либо о новых ресурсах  (возможно оба варинта);

    \item int my\_semop(int semid, struct sembuf *sops, unsigned nsops) в зависимости от проводимой операции (захват или освобождение ресурсов) посылает соответвующую операцию банкиру (если операций несколько , то поочередно), после положительного ответа и завершении непосредственно системного вызова, сообщает об успехе проведенной операции;
    \item int my\_semrm(int semid) удаляет идентификационный номер сета семафоров как из служебного процесса так и из системы. 

\end{itemize}

Так же в библиотеке присутсвуют дополнительные служебные функции, которые способствут упрощению обмена сообщениями между процессами, но не являются доступными пользователю. На них мы останавливаться не будем.

Все запросы, кроме выдачи ресурсов, в конечном счете сводятся к работе с данными, функция которая непосредственно реализует алгоритм банкира:
\\
{
\small
\verbatiminput{programms/check.c}
}

Данный код представляет собой реализацию блок-схемы, рассмотренной в теоритической части. В зависимости от того может ли запрос ресурсов привести к небезопасному состоянию принимается решение о разрешении ожидания ресурсов для исходного процесса. Если состояние может привести к тупиковой ситуации то метод возвращает отрицательное значение.

Количество процессов, одновременно <<общающихся>> с системой строго ограничено наперед заданной константой, аналогичная ситуация с количеством ресурсов (семафоров). 

<<Банкир>> при старте создет две служебные очереди, с одной он читает любые сообщения, которые на неё поступают и обрабатывает их в соответствующем порядке, приоритетных опрераций нет, в другую отправляет результат своих измышлений.   

Когда процесс сообщает о своем завершении все его данные удаляются из памяти процесса, соответственно освобождается место ддля работы других процессов. 
\subsection{Тесты}
Рассмотрим два примера работа программы. В одном из них возможная взаимная блокировка может возникнуть при использовании одного ресурса, в другом~--- двух. 
\\

\begin{figure}[h]
\centering
\includegraphics[width=10cm]{images/544.png}
\caption{Небезопасное состояние для одного ресурса.}
\label{fig.0}
\end{figure}

При подобном распределении может возникнуть тупик, соответственно функция check вернет отрицательные значения. Это можно увидеть, скомпилировав файл <<test.c>> и запустив его поочередно с ключами 2, 1, и 3. для наглядности и правильного порядка захвата ресурсов ввод с клавиатуры используется как <<ручной стопор>>.

Второй пример будет касаться захвата нескольких ресурсов для которого граф редукции будет выглядеть так:

\begin{figure}[h]
\centering
\includegraphics[width=5cm]{images/5555.png}
\caption{Небезопасное состояние для двух типов ресурса.}
\label{fig.0}
\end{figure}

Ситуация взаимоблокировки в этом случае возможна, если, после того как процесс A занял ресурс R1, произошло прерывание, в это время процесс B успел занять ресурс R2. Таким образом возникает тупиковая ситуация. Функция <<check>> не разрешит процессу B после прерывания ожидать ресурс R1. Этот пример реализован в файле <<test2.c>>; запускать следует изначально с параметром 1, а затем 2.


\endinput
